<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ProvidesMatchersWithSameValueHelper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Powerunit - Java Testing framework for JDK 1.8 - Extension to provide matchers based on annotations.</a> &gt; <a href="index.source.html" class="el_package">ch.powerunit.extensions.matchers.provideprocessor.helper</a> &gt; <span class="el_source">ProvidesMatchersWithSameValueHelper.java</span></div><h1>ProvidesMatchersWithSameValueHelper.java</h1><pre class="source lang-java linenums">package ch.powerunit.extensions.matchers.provideprocessor.helper;

import static ch.powerunit.extensions.matchers.common.CommonUtils.addPrefix;
import static java.lang.String.format;
import static java.util.Arrays.asList;
import static java.util.Arrays.stream;
import static java.util.Collections.emptyList;
import static java.util.Optional.of;
import static java.util.stream.Collectors.joining;

import java.util.Collection;
import java.util.Map.Entry;
import java.util.Optional;

import javax.lang.model.element.AnnotationMirror;
import javax.lang.model.element.AnnotationValue;
import javax.tools.Diagnostic.Kind;

import ch.powerunit.extensions.matchers.common.RessourceLoaderHelper;
import ch.powerunit.extensions.matchers.provideprocessor.Matchable;
import ch.powerunit.extensions.matchers.provideprocessor.ProvidesMatchersAnnotatedElementMirror;
import ch.powerunit.extensions.matchers.provideprocessor.dsl.DSLMethod;
import ch.powerunit.extensions.matchers.provideprocessor.dsl.lang.DSLMethodArgument;
import ch.powerunit.extensions.matchers.provideprocessor.fields.AbstractFieldDescription;

public final class ProvidesMatchersWithSameValueHelper {

<span class="fc" id="L28">	private static final String HAS_SAME_VALUE_IGNORE_CYCLE = RessourceLoaderHelper</span>
<span class="fc" id="L29">			.loadRessource(ProvidesMatchersWithSameValueHelper.class, &quot;DSLHasSameValueIgnoreAndCycle.txt&quot;);</span>

	private static final String JAVADOC_OTHER = &quot;other the other object to be used as a reference.&quot;;

	private static final String JAVDOC_PREVIOUS = &quot;previous the previous object of the call stack of matcher.&quot;;

	private static final String JAVADOC_IGNORE = &quot;ignoredFields fields name that must be ignored.&quot;;

	private static final String JAVADOC_POSTPROCESSOR = &quot;postProcessor Function to be applied to modify, if necessary, the matchers.&quot;;

	private static final String JAVADOC_OTHER_IGNORE = JAVADOC_OTHER + &quot;\n&quot; + JAVADOC_IGNORE;

	private static final String JAVADOC_OTHER_IGNORE_POSTPROCESSOR = JAVADOC_OTHER + &quot;\n&quot; + JAVADOC_IGNORE + &quot;\n&quot;
			+ JAVADOC_POSTPROCESSOR;

	private static final String JAVADOC_OTHER_PREVIOUS_IGNORE_POST = JAVADOC_OTHER + &quot;\n&quot; + JAVDOC_PREVIOUS + &quot;\n&quot;
			+ JAVADOC_IGNORE + &quot;\n&quot; + JAVADOC_POSTPROCESSOR;

	private ProvidesMatchersWithSameValueHelper() {
	}

	private static DSLMethod generateWithSameValueWithParentMatcherIgnoreAndCycle(
			ProvidesMatchersAnnotatedElementMirror target, boolean hasSuper) {
<span class="fc" id="L52">		return generateHasSameValueDeclaration(target)</span>
<span class="fc" id="L53">				.addOneArgument(target.getFullyQualifiedNameOfClassAnnotatedWithProvideMatcherWithGeneric(), &quot;other&quot;)</span>
<span class="fc" id="L54">				.addOneArgument(&quot;java.util.Set&lt;java.lang.Object&gt;&quot;, &quot;previous&quot;)</span>
<span class="fc" id="L55">				.addOneArgument(</span>
						&quot;java.util.function.BiFunction&lt;org.hamcrest.Matcher&lt;?&gt;,java.lang.Object,org.hamcrest.Matcher&lt;?&gt;&gt;&quot;,
						&quot;postProcessor&quot;)
<span class="fc" id="L58">				.addOneArgument(&quot;String...&quot;, &quot;ignoredFields&quot;)</span>
<span class="fc" id="L59">				.withImplementation(asList(format(HAS_SAME_VALUE_IGNORE_CYCLE,</span>
<span class="fc" id="L60">						target.getSimpleNameOfGeneratedInterfaceMatcherWithGenericNoParent(),</span>
<span class="fc" id="L61">						target.getSimpleNameOfGeneratedImplementationMatcherWithGenericNoParent(),</span>
<span class="fc" id="L62">						generateParentMatcher(target, hasSuper), copyFields(target),</span>
<span class="fc" id="L63">						target.getSimpleNameOfGeneratedInterfaceMatcher()).split(&quot;\n&quot;)))</span>
<span class="fc" id="L64">				.withJavadoc(target.generateDefaultJavaDocWithoutDSLStarter(of(JAVADOC_OTHER_PREVIOUS_IGNORE_POST),</span>
						&quot;the DSL matcher&quot;, false));
	}

	private static String generateParentMatcher(ProvidesMatchersAnnotatedElementMirror target, boolean hasSuper) {
<span class="pc bpc" id="L69" title="1 of 2 branches missed.">		return hasSuper ? (target.getParentMirror()</span>
<span class="nc" id="L70">				.map(p -&gt; &quot;(&quot; + p.getFullyQualifiedNameOfGeneratedClass() + &quot;.&quot;</span>
<span class="nc" id="L71">						+ p.getSimpleNameOfGeneratedInterfaceMatcher()</span>
						+ &quot;)java.util.Objects.requireNonNull(postProcessor,\&quot;postProcessor can't be null\&quot;).apply(&quot;
<span class="nc" id="L73">						+ p.getWithSameValue(false) + &quot;(other&quot;</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">						+ (p.supportSameValueWithParentPostPrecessor() ? &quot;,postProcessor&quot; : &quot;&quot;)</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">						+ (p.supportIgnore() ? &quot;,ignoredFields&quot; : &quot;&quot;) + &quot;),other)&quot;)</span>
<span class="pc" id="L76">				.orElse(&quot;org.hamcrest.Matchers.anything()&quot;)) : &quot;&quot;;</span>
	}

	private static String copyFields(ProvidesMatchersAnnotatedElementMirror target) {
<span class="pc" id="L80">		return target.getFields().stream().flatMap(f -&gt; stream(copyField(f).split(&quot;\n&quot;))).collect(joining(&quot;\n&quot;));</span>
	}

	private static String copyField(AbstractFieldDescription f) {
<span class="nc" id="L84">		String args = f</span>
<span class="nc" id="L85">				.getTargetAsMatchable().filter(Matchable::supportCycleDetectionV1).map(x -&gt; &quot;,nPrevious&quot;</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">						+ (x.supportSameValueWithParentPostPrecessor() ? &quot;,postProcessor&quot; : &quot;&quot;) + &quot;,localIgnored&quot;)</span>
<span class="nc" id="L87">				.orElse(&quot;,localIgnored&quot;);</span>
<span class="nc" id="L88">		return format(</span>
				&quot;if(!ignored.contains(\&quot;%1$s\&quot;)) {\n  String localIgnored[] = ignored.stream().filter(s-&gt;s.startsWith(\&quot;%1$s.\&quot;)).map(s-&gt;s.replaceFirst(\&quot;%1$s\\\\.\&quot;,\&quot;\&quot;)).toArray(String[]::new);\n%2$s\n}&quot;,
<span class="nc" id="L90">				f.getFieldName(), addPrefix(&quot;  &quot;, f.getFieldCopy(&quot;m&quot;, &quot;other&quot;, args)));</span>
	}

	private static DSLMethod generateWithSameValueWithParentMatcherIgnoreAndPostProcessor(
			ProvidesMatchersAnnotatedElementMirror target) {
<span class="fc" id="L95">		return generateHasSameValueDeclaration(target)</span>
<span class="fc" id="L96">				.addOneArgument(target.getFullyQualifiedNameOfClassAnnotatedWithProvideMatcherWithGeneric(), &quot;other&quot;)</span>
<span class="fc" id="L97">				.addOneArgument(</span>
						&quot;java.util.function.BiFunction&lt;org.hamcrest.Matcher&lt;?&gt;,java.lang.Object,org.hamcrest.Matcher&lt;?&gt;&gt;&quot;,
						&quot;postProcessor&quot;)
<span class="fc" id="L100">				.addOneArgument(&quot;String...&quot;, &quot;ignoredFields&quot;)</span>
<span class="fc" id="L101">				.withImplementation(generateReturnOther(target, &quot;postProcessor,ignoredFields&quot;))</span>
<span class="fc" id="L102">				.withJavadoc(target.generateDefaultJavaDocWithoutDSLStarter(of(JAVADOC_OTHER_IGNORE_POSTPROCESSOR),</span>
						&quot;the DSL matcher&quot;, false));
	}

	private static DSLMethod generateWithSameValueWithParentMatcherIgnore(
			ProvidesMatchersAnnotatedElementMirror target) {
<span class="fc" id="L108">		return generateHasSameValueDeclaration(target)</span>
<span class="fc" id="L109">				.addOneArgument(target.getFullyQualifiedNameOfClassAnnotatedWithProvideMatcherWithGeneric(), &quot;other&quot;)</span>
<span class="fc" id="L110">				.addOneArgument(&quot;String...&quot;, &quot;ignoredFields&quot;)</span>
<span class="fc" id="L111">				.withImplementation(generateReturnOther(target, &quot;(m,o)-&gt;m,ignoredFields&quot;)).withJavadoc(target</span>
<span class="fc" id="L112">						.generateDefaultJavaDocWithoutDSLStarter(of(JAVADOC_OTHER_IGNORE), &quot;the DSL matcher&quot;, false));</span>
	}

	private static DSLMethod generateWithSameValueWithParentMatcherAndNoIgnore(
			ProvidesMatchersAnnotatedElementMirror target) {
<span class="fc" id="L117">		return generateHasSameValueDeclaration(target)</span>
<span class="fc" id="L118">				.withOneArgument(target.getFullyQualifiedNameOfClassAnnotatedWithProvideMatcherWithGeneric(), &quot;other&quot;)</span>
<span class="fc" id="L119">				.withImplementation(generateReturnOther(target, &quot;(m,o)-&gt;m,new String[]{}&quot;)).withJavadoc(</span>
<span class="fc" id="L120">						target.generateDefaultJavaDocWithoutDSLStarter(of(JAVADOC_OTHER), &quot;the DSL matcher&quot;, false));</span>
	}

	private static String generateReturnOther(ProvidesMatchersAnnotatedElementMirror target, String complement) {
<span class="fc" id="L124">		return format(&quot;return %1$s(other,java.util.Collections.emptySet(),%2$s);&quot;,</span>
<span class="fc" id="L125">				target.getMethodNameDSLWithSameValue(), complement);</span>
	}

	private static DSLMethodArgument generateHasSameValueDeclaration(ProvidesMatchersAnnotatedElementMirror target) {
<span class="fc" id="L129">		return DSLMethod.of(</span>
<span class="fc" id="L130">				format(&quot;%1$s %2$s.%3$s %4$s&quot;, target.getFullGeneric(), target.getFullyQualifiedNameOfGeneratedClass(),</span>
<span class="fc" id="L131">						target.getSimpleNameOfGeneratedInterfaceMatcherWithGenericNoParent(),</span>
<span class="fc" id="L132">						target.getMethodNameDSLWithSameValue()));</span>
	}

	private static boolean isWeakAllowed(ProvidesMatchersAnnotatedElementMirror target) {
<span class="nc" id="L136">		return target.getRealAnnotation().allowWeakWithSameValue();</span>
	}

	private static void logWeak(ProvidesMatchersAnnotatedElementMirror target) {
<span class="nc" id="L140">		Optional&lt;AnnotationMirror&gt; am = target.getAnnotationMirror();</span>
<span class="nc" id="L141">		Optional&lt;? extends AnnotationValue&gt; av = am.map(a -&gt; a.getElementValues().entrySet().stream()</span>
<span class="nc" id="L142">				.filter(kv -&gt; kv.getKey().getSimpleName().toString().equals(&quot;allowWeakWithSameValue&quot;))</span>
<span class="nc" id="L143">				.map(Entry::getValue).findAny().orElse(null));</span>
<span class="nc" id="L144">		target.getMessager().printMessage(Kind.MANDATORY_WARNING,</span>
				&quot;This class use the option allowWeakWithSameValue and a weak WithSameValue is detected. The generated WithSameValue DSL may not be able to fully control all the field of this class&quot;,
<span class="nc" id="L146">				target.getElement(), am.orElse(null), av.orElse(null));</span>
<span class="nc" id="L147">	}</span>

	public static Collection&lt;DSLMethod&gt; generateParentValueDSLStarter(ProvidesMatchersAnnotatedElementMirror target) {
<span class="nc" id="L150">		return target.getParentMirror()</span>
<span class="nc" id="L151">				.map(parentMirror -&gt; asList(generateWithSameValueWithParentMatcherIgnoreAndCycle(target, true),</span>
<span class="nc" id="L152">						generateWithSameValueWithParentMatcherIgnoreAndPostProcessor(target),</span>
<span class="nc" id="L153">						generateWithSameValueWithParentMatcherIgnore(target),</span>
<span class="nc" id="L154">						generateWithSameValueWithParentMatcherAndNoIgnore(target)))</span>
<span class="nc" id="L155">				.orElseGet(() -&gt; {</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">					if (isWeakAllowed(target)) {</span>
<span class="nc" id="L157">						logWeak(target);</span>
<span class="nc" id="L158">						return asList(generateWithSameValueWithParentMatcherIgnoreAndCycle(target, true),</span>
<span class="nc" id="L159">								generateWithSameValueWithParentMatcherIgnoreAndPostProcessor(target),</span>
<span class="nc" id="L160">								generateWithSameValueWithParentMatcherIgnore(target),</span>
<span class="nc" id="L161">								generateWithSameValueWithParentMatcherAndNoIgnore(target));</span>
					} else {
<span class="nc" id="L163">						return emptyList();</span>
					}
				});
	}

	public static Collection&lt;DSLMethod&gt; generateNoParentValueDSLStarter(ProvidesMatchersAnnotatedElementMirror target) {
<span class="fc" id="L169">		return asList(generateWithSameValueWithParentMatcherIgnoreAndCycle(target, false),</span>
<span class="fc" id="L170">				generateWithSameValueWithParentMatcherIgnoreAndPostProcessor(target),</span>
<span class="fc" id="L171">				generateWithSameValueWithParentMatcherIgnore(target),</span>
<span class="fc" id="L172">				generateWithSameValueWithParentMatcherAndNoIgnore(target));</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>